要构造每一个种类ci,但不同种类之间除了容器相同没有交叉的运算:
  //简化版本的算法//
    阶段A:训练算法
      1.无脑构造总词集并初始化为0并计算出p(ci)
      2.构造ci的每一个扁平化词集并分别在总词集上体现出来
      3.将ci的每一个扁平化词集汇总并计算出每一个词的出现频率(/)
        <<这就是用类别ci的频率来训练概率,轨迹空间是离散的,注意这里的条件概率是浑然一体的存在>>
        <<(w|c)浑然一体以至于(c|x)的含义难以理解,时序图的层次也难以理清>>
    阶段B:测试算法(对于某一个给定的词向量w)
      4.对于每一个词有p(wj|ci)=[j](w从0开始)
        对于某一个词向量有p(w|ci)=∏p(wj|ci),可以依据词典进行计算
      5.运用上述【混元】的p(ci)进行计算
      6.比较p(ci|wj)的大小并完成分类

  //强化版本的算法//
    针对3.训练时由于朴素贝叶斯特性是乘法拆解
      a.将计算wj|ci次数的基底初始化为1.0
      b.将计算w|ci次数的基底初始化为2.0
        <<a和b的取值之间没有关系,是一种对频率的重构造>>
    针对4.测试时由于数量级太小会导致下溢
      a.p(ci|w):=log(p(ci|w))=Σ(log(p(wj|ci))+log(p(ci))
        <<伪代码:sum(总词集上的扁平化词集,log(被训练好的词典)+log(p(ci)))>>
        <<单调性和极值相同,是一种对逆概率的重构造>>
      